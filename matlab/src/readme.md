# 图像旋转算法整理

- [图像旋转算法整理](#%e5%9b%be%e5%83%8f%e6%97%8b%e8%bd%ac%e7%ae%97%e6%b3%95%e6%95%b4%e7%90%86)
  - [1 图像旋转基本知识](#1-%e5%9b%be%e5%83%8f%e6%97%8b%e8%bd%ac%e5%9f%ba%e6%9c%ac%e7%9f%a5%e8%af%86)
  - [文献参考](#%e6%96%87%e7%8c%ae%e5%8f%82%e8%80%83)
    - [不同插值方法实现数字图像旋转研究](#%e4%b8%8d%e5%90%8c%e6%8f%92%e5%80%bc%e6%96%b9%e6%b3%95%e5%ae%9e%e7%8e%b0%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e6%97%8b%e8%bd%ac%e7%a0%94%e7%a9%b6)
      - [最近邻算法](#%e6%9c%80%e8%bf%91%e9%82%bb%e7%ae%97%e6%b3%95)
      - [双线性插值法](#%e5%8f%8c%e7%ba%bf%e6%80%a7%e6%8f%92%e5%80%bc%e6%b3%95)
      - [双三线性插值法](#%e5%8f%8c%e4%b8%89%e7%ba%bf%e6%80%a7%e6%8f%92%e5%80%bc%e6%b3%95)
      - [三种插值方法的比较](#%e4%b8%89%e7%a7%8d%e6%8f%92%e5%80%bc%e6%96%b9%e6%b3%95%e7%9a%84%e6%af%94%e8%be%83)

## 1 图像旋转基本知识

旋转的三要素是:

- 旋转中心
- 旋转角度
- 旋转方向

特征：

1. 对应点到旋转中心的距离相等.
2. 对应点与旋转中心所连线段的夹角等于旋转角.
3. 旋转前、后的图形全等.

图像旋转概述：
在平面内，将一个图像绕一个顶点旋转一定的角度，这样的图像运动叫做图像旋转。
`图像的旋转是图像几何变换的一种，旋转前后的图像的像素的RGB都是没有改变的，改变的只是每一个像素的所在位置，这个就是旋转的本质：`
把原图像像素从原点(x,y)放到目标位置点上(x',y')，这个(x,y)到(x',y')的转换是经过旋转计算而来的，那么这个图像处理就是旋转处理(几何变换)

原理：
`自然会有这样一个属性：旋转前和旋转后的点离中心的位置不变。`
根据这个属性，我们可以得到旋转后的点的坐标与原坐标的对应关系。
由于原图像的坐标是以左上角为原点的，所以我们先把坐标转换为以图像中心为原点。假设原图像的宽为w，高为h，(x0,y0)为原坐标内的一点，转换坐标后的点为(x1，y1)。
那么不难得到：
$$x1=x0-w/2;$$
$$y1=-y0+h/2;$$
在新的坐标系下，假设点(x0，y0)距离原点的距离为r，点与原点之间的连线与x轴的夹角为b，旋转的角度为a，旋转后的点为(x1，y1), 如下图所示。

那么有以下结论：
$$x0=rcosb$$
$$y0=rsinb$$
$$x1=rcos(b-a)=rcosbcosa+rsinbsina=x0cosa+y0sina;$$
$$y1=rsin(b-a)=rsinbcosa-rcosbsina=-x0sina+y0cosa;$$
得到了转换后的坐标，我们只需要把这些坐标再转换为原坐标系即可。这里还有一点要注意，旋转后的图像的长和宽会发生变化，因此要计算新图像的长和宽.

## 文献参考

### [不同插值方法实现数字图像旋转研究](http://xueshu.baidu.com/usercenter/paper/show?paperid=dcec566cc69eaf79cd0aeb691291c140&site=xueshu_se)

摘要：分析了图像旋转的几何原理，并对图像旋转中用到的插值处理方法，即：

- 最近邻法
- 双线性插值法
- 双三线性插值法

进行了比较和分析，在此基础上对其应用进行了阐述。

正文：

这样，对于新图中的每一点(x1，y1)，可以根据公式求出对应原图中的(x0，y0)，得到它的灰度，如果超出原图范围，则填成白色。
要注意的是，原始图像的像素坐标为整数，由于有浮点运算，变换后的目标图像的坐标位置可能不是整数。
所以，图像的旋转处理，除了要进行几何运算，还需要对目标图像的坐标位置进行插值处理。

常用的插值方法有 3 种：最近邻法、双线性插值法和双三线性插值法。

#### 最近邻算法

最近邻法是一种简单的插值方法，它是通过计算于点(x0，y0)邻近的 4 个点，将与点(x0，y0)最近的整数坐标点的像素值取为(x0，y0)点的像素值。

#### 双线性插值法

对于一个目的像素，通过反向变换得到浮点坐标(x+u，y+v)，其中 x、y 均为非负整数，u、v 为[0，1)区间的浮点数，则这个像素的值可由源图中坐标为 (x，y)、(x+1，y)、(x，y+1)、(x+1，y+1)4 个点所对应的像素的值确定，即：

$f(x+u,y+v)=(1-u)(1-v)*f(x,y)+(1-u)v*f(x，y+1)+u(1-v)*f(x+1，y)+uv*f(x+1，y+1)$

其中，f(x，y)代表源图像(x，y)处的像素值，以此类推。
这就是双线性插值法，它考虑到了点(x，y)的 4 个直接邻点对它的影响，因此一般可以得到令人满意的插值效果。

#### 双三线性插值法

双线性插值法考虑到浮点坐标（x+u，y+v）的 4 个直接邻点对它的影响， 而双三插值法则考虑到该点周围 16 个邻点对它的影响。
目标坐标的像素值可由如下的公式得到：$f(x+u,y+v)= ABC$

<div align="center">
  <img src=imgs/1.r.1.3.PNG width="720px"/>
</div>

#### 三种插值方法的比较

表 1 三种插值方法比较

插值方法 | 性能特点
-|-
最近邻法 | 处理时间最短，实时性比较好，但得到的图像质量不高，在旋转的过程中容易产生锯齿状边界。适用于要求旋转实时性高，但对图像质量要求不高的程序
双线性 | 相对最近邻插值法，其速度慢，但是得到的图像质量高，纹理较清晰，能满足大多数程序的要求。
双三线性 | 处理速度最慢，但相应的得到的图像的质量最高，适用于对图像质量要求比较高的程序，一般很少使用。

---

cmake -G"Unix Makefiles" .

$F(x, y)=u* \{ x \} + v$

$v=[f(\lfloor x\rfloor, \lceil y \rceil) - f(\lfloor x\rfloor, \lfloor y \rfloor)]*\{ y \}+\lfloor x\rfloor$

$u=[f(\lceil x \rceil, \lceil y \rceil)-f(\lceil x \rceil, \lfloor y\rfloor)]*\{ y \}+\lceil x \rceil-v$
